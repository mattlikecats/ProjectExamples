#include <iostream>
#include <fstream>
#include <string>

#include "hash.hpp"

using namespace std;

int getWordCount(string input, char delim) // Used to determine if there was only 1 word in the string, like #5 but more flexable because static ' ' was replaced with the delim char.
{
    if (input == "") // Simple if statement to check for no input and returns 0
    {
        return 0;
    }
    int counter = 1; // 2. Counter determines word count, matters if counter is either 1 or > 1.
    
    for (int i =0; i< input.length();i++)
    {
        
        if( input[i] == delim)
        {
            counter ++;
        }
        else
        {
            continue;
        }
    }
    
    return counter;
    
}

int split(string str, char delim, string arr[], int len)
{
    string temp; //temp string used to store rotation strings generated by the for loop;
    int place = 0;
    int spaces = 1;
    
    int wordcount = getWordCount(str,delim); // 3. wordcount is used in the consecutive elseif statement to determine the case that the string is only one word without delimitors. 
    if(str == "")
    {
        return 0;
    }
    else if (wordcount == 1)
    {
        arr[0] = str; // 3a. returns arr[0] as the string if elseif condition is met, does not follow through program.
        return spaces;
    }
    else // 4. else statement runs through multiple if and if/else statements to determine many things;
    {
        if((str[0] == delim)) // 4a. if the string starts with a delim, removes it from string
        {
            str = str.substr(1, str.length()-1);
        }
        if(str[str.length()-1] != delim) // 4b. if the last char of the string isn't a delim, add one (helps program find end later)
        {
            str = str + delim;
        }
        for (int i = 0; i < str.length(); i++) // 5. for loop designed to traverese the length of the string and run multiple if and if/else statements;
        {
            if((str[i] == delim) && (i != str.length()-1)) // 5a. main if statement that determines when the string should be cut and stored in the array, moves counter variable "spaces" and elevator variable "place". Temp is reset to nothing.
            {
                if(str[i] == str[i+1]) // 5b. IMPORTANT IF STATEMENT WITHIN THIS STATEMENT THAT RECOGNIZES MULTIPLE DELIM CHARS NEXT TO EACH OTHER AND SKIP THE BREAK PROCEDURE ONCE
                {
                    continue;
                }
                arr[place] = temp;
                spaces++;
                place++;
                temp = "";
                
            }
            else if((str[i] != delim)) // 5c. adds the currently compared str[] value to a temp varaible "temp" that store the string until the if statement activation above it.
            {
                temp = temp+str[i];
            }
            else // 5d. else statement ends the loop when the main if statement recognizes that the last added or kept delim exsists, ending the function.  
            {
                arr[place] = temp;
                break;
            }
        }
        return spaces;
    }
}

void fillData(string filename, int testData[])
{
    ifstream link;
    link.open(filename);
    if(link.is_open())
    {
        string line;
        int count;
        while(getline(link,line,',') && count < 40000)
        {
            testData[count] = stoi(line);
            count++;
        }
    }
    else
    {
        cout << "Failed!" << endl;
        return;
    }
    
    link.close();
}

int main()
{

    int testDataB[40000];

    string B = "dataSetB.csv";

    fillData(B, testDataB);

    Hash tableB(40009);
    int countB = 0;

    float insertBC[400];
    float insertBL[400];
    float insertBQ[400];

    

    float searchBC[400];
    float searchBL[400];
    float searchBQ[400];





    for (int k = 0; k < 400; k++)
    {
        tableB.next100C(testDataB, insertBC, countB);
        tableB.next100L(testDataB, insertBL, countB);
        tableB.next100Q(testDataB, insertBQ, countB);
        
        countB = countB + 100;

        tableB.randSearchC(testDataB, searchBC, countB);
        tableB.randSearchL(testDataB, searchBL, countB);
        tableB.randSearchQ(testDataB, searchBQ, countB);

    }

    

    // B data insertion ************************************************************** 

    ofstream IBC;
    IBC.open("Hash_insert_BC.txt");

    for (int i = 0; i < 400; i++)
    {
        IBC << insertBC[i] << endl;
    }

    IBC.close();

    ofstream IBL;
    IBL.open("Hash_insert_BL.txt");

    for (int i = 0; i < 400; i++)
    {
        IBL << insertBL[i] << endl;
    }

    IBL.close();

    ofstream IBQ;
    IBQ.open("Hash_insert_BQ.txt");

    for (int i = 0; i < 400; i++)
    {
        IBQ << insertBQ[i] << endl;
    }

    IBQ.close();

    

    // B data search ***********************************************************

    ofstream SBC;
    SBC.open("Hash_search_BC.txt");

    for (int i = 0; i < 400; i++)
    {
        SBC << searchBC[i] << endl;
    }

    SBC.close();

    ofstream SBL;
    SBL.open("Hash_search_BL.txt");

    for (int i = 0; i < 400; i++)
    {
        SBL << searchBL[i] << endl;
    }

    SBL.close();

    ofstream SBQ;
    SBQ.open("Hash_search_BQ.txt");

    for (int i = 0; i < 400; i++)
    {
        SBQ << searchBQ[i] << endl;
    }

    SBQ.close();


}