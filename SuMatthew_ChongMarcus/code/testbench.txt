#include <iostream>
#include <string>
#include <fstream>
#include "LinkedList.hpp"
#include "BST.hpp"
//include "Hash.hpp"

using namespace std;

int getWordCount(string input, char delim) // Used to determine if there was only 1 word in the string, like #5 but more flexable because static ' ' was replaced with the delim char.
{
    if (input == "") // Simple if statement to check for no input and returns 0
    {
        return 0;
    }
    int counter = 1; // 2. Counter determines word count, matters if counter is either 1 or > 1.
    
    for (int i =0; i< input.length();i++)
    {
        
        if( input[i] == delim)
        {
            counter ++;
        }
        else
        {
            continue;
        }
    }
    
    return counter;
    
}

int split(string str, char delim, string arr[], int len)
{
    string temp; //temp string used to store rotation strings generated by the for loop;
    int place = 0;
    int spaces = 1;
    
    int wordcount = getWordCount(str,delim); // 3. wordcount is used in the consecutive elseif statement to determine the case that the string is only one word without delimitors. 
    if(str == "")
    {
        return 0;
    }
    else if (wordcount == 1)
    {
        arr[0] = str; // 3a. returns arr[0] as the string if elseif condition is met, does not follow through program.
        return spaces;
    }
    else // 4. else statement runs through multiple if and if/else statements to determine many things;
    {
        if((str[0] == delim)) // 4a. if the string starts with a delim, removes it from string
        {
            str = str.substr(1, str.length()-1);
        }
        if(str[str.length()-1] != delim) // 4b. if the last char of the string isn't a delim, add one (helps program find end later)
        {
            str = str + delim;
        }
        for (int i = 0; i < str.length(); i++) // 5. for loop designed to traverese the length of the string and run multiple if and if/else statements;
        {
            if((str[i] == delim) && (i != str.length()-1)) // 5a. main if statement that determines when the string should be cut and stored in the array, moves counter variable "spaces" and elevator variable "place". Temp is reset to nothing.
            {
                if(str[i] == str[i+1]) // 5b. IMPORTANT IF STATEMENT WITHIN THIS STATEMENT THAT RECOGNIZES MULTIPLE DELIM CHARS NEXT TO EACH OTHER AND SKIP THE BREAK PROCEDURE ONCE
                {
                    continue;
                }
                arr[place] = temp;
                spaces++;
                place++;
                temp = "";
                
            }
            else if((str[i] != delim)) // 5c. adds the currently compared str[] value to a temp varaible "temp" that store the string until the if statement activation above it.
            {
                temp = temp+str[i];
            }
            else // 5d. else statement ends the loop when the main if statement recognizes that the last added or kept delim exsists, ending the function.  
            {
                arr[place] = temp;
                break;
            }
        }
        return spaces;
    }
}

void fillData(string filename, int testData[])
{
    ifstream link;
    link.open(filename);
    if(link.is_open())
    {
        string line;
        int count;
        while(getline(link,line,',') && count < 40000)
        {
            testData[count] = stoi(line);
            count++;
        }
    }
    else
    {
        cout << "Failed!" << endl;
        return;
    }
    
    link.close();
}


int expBST(string filename);
int expHash(string filename);

int main()

{


    // for (int i = 0; i < 100; i++)
    // {
    //     cout << testData[i] << endl;
    // }

    //**************************************************************************

    //Linked List Experiment

    // LinkedList list;
    // int count = 0;

    // // list.expLinkedInsert(list, testData, insert, count);
    // Node* curr = NULL; //given as a starting prev for insert
    
    // // for(int i = 0; i < 400; i++)
    // // {
    // //     list.expLinkedInsert(curr, testData, insert, count);
    // //     count = count + 100;
    // //     curr = list.search(testData[count-1]);
    // // }

    // // cout << count << endl;
    // // cout << curr->key << endl;

    // list.expLinkedInsert(curr, testData, insert, count);
    // count = count + 100;
    // curr = list.search(testData[count-1]);

    // // if(curr->key == 52746)
    // // {
    // //     cout << "good" << endl;
    // // }
    // // else
    // // {
    // //     cout << "failed" << endl;
    // // }
    // cout << endl;

    // cout << insert[(count + 100)/100] << endl;

    // list.randSearch(count, testData, search);

    // cout << endl;

    // list.expLinkedInsert(curr, testData, insert, count);
    // count = count + 100;
    // curr = list.search(testData[count-1]);

    // // if(curr->key == 52746)
    // // {
    // //     cout << "good" << endl;
    // // }
    // // else
    // // {
    // //     cout << "failed" << endl;
    // // }
    // cout << endl;

    // cout << insert[(count + 100)/100] << endl;

    // list.randSearch(count, testData, search);

    // cout << endl;

    //*************************************************************************




    // linked list A

    int testData[40000];
    Node* curr = NULL;

    string A = "dataSetA.csv";
    string B = "dataSetB.csv";

    fillData(A, testData); //fills the data array

    LinkedList list;
    int count = 0;
    int count2 = 0;

    float insertLink[400];
    float searchLink[400];

    ofstream out_file;
    out_file.open("linked_list_dataSetA.txt");
    
    for(int i = 0; i < 400; i++)
    {
        list.expLinkedInsert(curr, testData, insertLink, count);
        count = count + 100;
        curr = list.search(testData[count-1]);
    }

    for (int i = 0, i < 400, i++)
    {
        list.randSearch(count, testData, searchLink);
        count2 = count2 + 100;
    }

    for (int i = 0, i < 400, i++)
    {
        out_file << insertLink[i] << endl;
        out_file << searchLink[i] << endl;
    }
    
    out_file.close();



    // linked list B

    int testData2[40000];
    Node* curr2 = NULL;

    fillData(B, testData2); //fills the data array

    LinkedList list;
    int count3 = 0;
    int count4 = 0;

    float insertLink2[400];
    float searchLink2[400];

    ofstream out_file;
    out_file.open("linked_list_dataSetB.txt");
    
    for(int i = 0; i < 400; i++)
    {
        list.expLinkedInsert(curr2, testData2, insertLink2, count2);
        count3 = count3 + 100;
        curr2 = list.search(testData[count-1]);
    }

    for (int i = 0, i < 400, i++)
    {
        list.randSearch(count4, testData2, searchLink2);
        count4 = count4 + 100;
    }

    for (int i = 0, i < 400, i++)
    {
        out_file << insertLink2[i] << endl;
        out_file << searchLink2[i] << endl;
    }
    
    out_file.close();

    //BST A
    
    BST tree;
    float insertBST[400]; // average insertion time array
    float searchBST[400]; // average search time array

    int BSTcount = 0; 
    int BSTcount2 = 0;
    //count for BST Experiment

    tree.expBSTInsert(testData, insertBST, count2);
    count2 = count2 + 100;
    tree.randSearch(count2, testData, search);


    

}